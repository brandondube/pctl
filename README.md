# pctl

pctl, "process control" is a package for process control in Go.  This applies to industrial processes, not the computer science term.

It contains a streaming PID controller that communicates using channels.

## Usage

```go
import pctl

controller := pctl.PIDCtl{
    P: 10,
    I: 1,
    D: 0, // PI, not PID.
}
controller.Setpt = 50
measC := make(chan float64) // unbuffered or buffered makes no difference
outC := make(chan float64)

go pollSensor(measC) // this functions writes f64s to measC
go processesOutputs(outC) // this function reads f64s from outC
go controller.Start(measC, outC)
```
While the controller is running, you can adjust the setpoint or gains, query the measurement and output values, or the clock:
```go
v1 := controller.Meas
v2 := controller.Setpt
controller.Setpt = 55
```
In simple terms, you can access the struct fields or the `LastObs()` method.  By default, the controller does not use a lock during the loop.  Accessing the fields may result
in desyncronization in this case, though it will not make a meaningful difference in the numerical values if the system has stabilized.  If synchronicity is more important than performance, enable locking: `controller.EnableLocking()`.  This can be done while the controller is running.

To monitor (instrument) the process and controller at a regular interval, you can use a `time.Timer`:

```go
import time

pollFreq := time.Second()
timer := time.NewTimer(pollFreq)
go func() {
    // if you're using the locking mode, this blocks the loop
    // controller.Lock()

    ts := <-timer.C
    pV := controller.Meas
    pO := controller.Output

    // controller.Unlock() // if you locked

    // do something with ts, pV, pO
    // write to CSV file or database, etc.
}()

// wait some time
controller.Stop() // this will stop the control loop
timer.Stop()
```
Notice that in this form, the monitor and control intervals are decoupled.  To couple them, process the values inside the functions that write to and read from the channels used by `Loop()`.  You can use a closure to give the output processing function access to the controller so it can access parameters like the Setpt.

# Tips

The controller does not provide the clock, which is instead generated by the function(s) writing to the measurement channel.  The PID algorithm is discrete time, and does not depend on a regular update interval.

When using the controller in a locking mode with unbuffered channels, remember that acquiring the lock will block the function writing to the input channel.

In nonlocking mode, the control loop can run at about 2 MHz on a laptop and will likely be limited by the sensor polling and output writing function latency:
```
goos: darwin
goarch: amd64
pkg: github.com/brandondube/pctl
BenchmarkPIDLoopNonLocking-12    	 2086852	       530 ns/op	       0 B/op	       0 allocs/op
BenchmarkPIDLoopLocking-12       	 1957621	       561 ns/op	       0 B/op	       0 allocs/op
PASS
ok  	github.com/brandondube/pctl	3.541s
```

The performance hit from the internal lock is low, but the stop the world pauses caused by your acquisition of the lock will freeze the controller as well.
